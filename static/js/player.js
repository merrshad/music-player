
const $ = document.querySelector.bind(document);
const $$ = document.querySelectorAll.bind(document);

const PLAYER_STORAGE_KEY = "Music_Player_D2D_Local"; // Changed key slightly

const player = $(".c-player");
const cd = $(".c-player__cd");
const cdThumb = $(".c-player__cd-thumb"); // Updated selector
const currentTitle = $("#current-title"); // Use ID from HTML
const currentArtist = $("#current-artist"); // Use ID from HTML
const playBtn = $(".btn-toggle-play");
const nextBtn = $(".btn-next");
const prevBtn = $(".btn-prev");
const randomBtn = $(".btn-random");
const repeatBtn = $(".btn-repeat");
const progress = $("#progress-bar"); // Use ID from HTML
const audio = $("#js-player-audio"); // Use ID from HTML
const playListContainer = $(".c-player__playlist"); // Container for songs
const currentTimeEl = $(".c-player__progress-start-time");
const durationEl = $("#js-duration-song"); // Use ID from HTML


const app = {
  currentIndex: 0,
  songsData: [], // Will be populated from HTML
  isPlaying: false,
  isRandom: false,
  isRepeat: false,
  config: JSON.parse(localStorage.getItem(PLAYER_STORAGE_KEY)) || {},

  setConfig: function (key, value) {
    this.config[key] = value;
    localStorage.setItem(PLAYER_STORAGE_KEY, JSON.stringify(this.config));
  },

  loadConfig: function() {
    this.isRandom = this.config.isRandom || false;
    this.isRepeat = this.config.isRepeat || false;
    // Apply initial button states
    randomBtn.classList.toggle("active", this.isRandom);
    repeatBtn.classList.toggle("active", this.isRepeat);
    // Load last played song index if saved (optional)
    // this.currentIndex = this.config.currentIndex || 0;
  },

  // Function to extract song data from the HTML structure
  extractSongsFromHTML: function() {
    const songElements = $$(".c-player__song");
    songElements.forEach((songEl, index) => {
      this.songsData.push({
        index: index + 1, // Use loop index + 1 for display number
        name: songEl.dataset.title,
        singer: songEl.dataset.artist,
        duration: "0:00", // Placeholder, will be updated on load
        image: songEl.dataset.image,
        path: songEl.dataset.src,
        element: songEl // Keep a reference to the DOM element
      });
    });
    // Update the actual duration display in the playlist once loaded
    this.updatePlaylistDurations();
  },

  updatePlaylistDurations: function() {
     this.songsData.forEach((song, index) => {
         const tempAudio = new Audio(song.path);
         tempAudio.addEventListener('loadedmetadata', () => {
             const durationDisplay = song.element.querySelector('.c-player__song-duration');
             if (durationDisplay) {
                 song.duration = this.formatTime(tempAudio.duration);
                 durationDisplay.textContent = song.duration;
             }
         });
     });
  },

  defineProperties: function () {
    Object.defineProperty(this, "currentSong", {
      get: function () {
        return this.songsData[this.currentIndex];
      }
    });
  },

  // No need for renderSongs as HTML is already generated by Flask
  // renderSongs: function () { ... }

  handleEvents: function () {
    const _this = this;

    // CD rotation animation
    let cdRotate;
    if (cdThumb) { // Check if cdThumb exists
        cdRotate = cdThumb.animate([{ transform: "rotate(360deg)" }], {
            duration: 10000, // 10 seconds per rotation
            iterations: Infinity
        });
        cdRotate.pause(); // Start paused
    }

    // Play/Pause button click
    playBtn.onclick = function () {
      if (_this.isPlaying) {
        audio.pause();
      } else {
        audio.play();
      }
    };

    // Audio events
    audio.onplay = function () {
      _this.isPlaying = true;
      player.classList.add("playing");
      player.classList.remove("paused");
      if(cdRotate) cdRotate.play();
    };
    audio.onpause = function () {
      _this.isPlaying = false;
      player.classList.remove("playing");
      player.classList.add("paused");
      if(cdRotate) cdRotate.pause();
    };

     // Time update for progress bar
     audio.ontimeupdate = function () {
         if (audio.duration) {
             const progressPercent = Math.floor((audio.currentTime / audio.duration) * 100); // Ensure integer value
             progress.value = progressPercent;
         }
         currentTimeEl.textContent = _this.formatTime(audio.currentTime); // Always update display
    };

    // Seeking using progress bar
    progress.oninput = function (e) { // Use oninput for smoother seeking while dragging
        const seekTime = (e.target.value / 100) * audio.duration;
        if (!isNaN(seekTime)) { // Prevent errors if duration is not loaded yet
            audio.currentTime = seekTime;
        }
    };

    // Next song button
    nextBtn.onclick = function () {
      if (_this.isRandom) {
        _this.playRandomSong();
      } else {
        _this.nextSong();
      }
      audio.play(); // Autoplay next/random song
      _this.scrollToActiveSong();
    };

    // Previous song button
    prevBtn.onclick = function () {
      if (_this.isRandom) {
        _this.playRandomSong(); // Random behaves same on prev/next
      } else {
        _this.prevSong();
      }
      audio.play(); // Autoplay previous/random song
      _this.scrollToActiveSong();
    };

    // Random button toggle
    randomBtn.onclick = function () {
      _this.isRandom = !_this.isRandom;
      _this.setConfig('isRandom', _this.isRandom);
      randomBtn.classList.toggle("active", _this.isRandom);
    };

    // Repeat button toggle
    repeatBtn.onclick = function () {
      _this.isRepeat = !_this.isRepeat;
       _this.setConfig('isRepeat', _this.isRepeat);
      repeatBtn.classList.toggle("active", _this.isRepeat);
    };

    // Song end handling
    audio.onended = function () {
      if (_this.isRepeat) {
        audio.play(); // Replay the current song
      } else {
        nextBtn.click(); // Go to the next song
      }
    };

    // Playlist item click
    playListContainer.onclick = function (e) {
      const songNode = e.target.closest(".c-player__song:not(.active)");
      if (songNode) {
        // Find the index based on the clicked element
        const clickedIndex = Array.from(_this.songsData).findIndex(song => song.element === songNode);
        if(clickedIndex !== -1) {
            _this.currentIndex = clickedIndex;
            _this.loadCurrentSong();
            audio.play();
        }
      }
    };

    // Update duration when metadata loads
    audio.onloadedmetadata = function() {
        durationEl.textContent = _this.formatTime(audio.duration);
    };

  },

  // --- Helper Functions ---

  formatTime: function(seconds) {
      if (isNaN(seconds)) return "0:00";
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
  },

  loadCurrentSong: function () {
    if (!this.currentSong) return; // Check if currentSong exists

    currentTitle.textContent = this.currentSong.name;
    currentArtist.textContent = this.currentSong.singer;
    if (cdThumb) { // Check if cdThumb exists
        cdThumb.style.backgroundImage = `url('${this.currentSong.image}')`;
    }
    audio.src = this.currentSong.path;
    durationEl.textContent = this.currentSong.duration; // Display initial/cached duration
    currentTimeEl.textContent = '0:00';
    progress.value = 0;

    // Highlight active song in the playlist
    const currentActive = $(".c-player__song.active");
    if (currentActive) {
      currentActive.classList.remove("active");
    }
    if (this.currentSong.element) { // Check if element reference exists
        this.currentSong.element.classList.add("active");
    }
    // console.log("Loading song:", this.currentSong.name);
  },

  nextSong: function () {
    this.currentIndex++;
    if (this.currentIndex >= this.songsData.length) {
      this.currentIndex = 0;
    }
    this.loadCurrentSong();
  },

  prevSong: function () {
    this.currentIndex--;
    if (this.currentIndex < 0) {
      this.currentIndex = this.songsData.length - 1;
    }
    this.loadCurrentSong();
  },

  playRandomSong: function () {
    let newIndex;
    // Basic random: prevent playing the same song twice in a row
    do {
      newIndex = Math.floor(Math.random() * this.songsData.length);
    } while (newIndex === this.currentIndex);
    this.currentIndex = newIndex;
    this.loadCurrentSong();
  },

  scrollToActiveSong: function () {
    setTimeout(() => {
       if (this.currentSong && this.currentSong.element) { // Check references
           this.currentSong.element.scrollIntoView({
               behavior: "smooth",
               block: "nearest" // Changed from 'end' to 'nearest' or 'center'
           });
       }
    }, 300); // Delay slightly
  },

  // --- Initialization ---

  start: function () {
    this.loadConfig(); // Load settings like repeat/random
    this.extractSongsFromHTML(); // Get song info from the DOM
    if (this.songsData.length > 0) { // Check if songs were found
        this.defineProperties(); // Setup getter for currentSong
        this.handleEvents(); // Attach event listeners
        this.loadCurrentSong(); // Load the initial song (index 0)
        player.classList.add("paused"); // Set initial visual state to paused
    } else {
        console.error("No songs found in the playlist HTML.");
        // Optionally display a message to the user
    }
  }
};

// Start the application once the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    app.start();
});
